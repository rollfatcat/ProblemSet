/* 透過帶入不同的Ｎ可以觀察出規律： 
 * 將Ｎ轉成二進位來看，若Ｎ有 p 個0，則答案為 2^p 
 * 除此之外，需要特別判斷Ｎ＝0 的狀況，還有小心溢位(MAXN=1e15)
 * 若Ｎ(二進位表示後)的某位數為 0 ，則無論 i 的那位數是 0 或 1 都與加法相同
 * 若Ｎ(二進位表示後)的某位數為 1 則僅有在 i 那位數為 0 下的狀況才會成立
 *   若 i 對應的位數為 1 在 XOR 下會變 0 ，而加法下則會進位，若Ｎ的下一位也是 1 ，則 i 的下一位數也需要是 1 否則會出現加法不等於 XOR 的結果，
 *   直到最後進位了，即是 n+i > n^i ，若在發生無可奈何的進位之前 n 出現 0 的話，則 i 不管是 0 或 1 都無法處理該情況，故 n 的某位為 1 時， i 僅有一種選擇
 */
#include<bits/stdc++.h>
using namespace std;

int main(){
    long N;
    while(scanf("%ld",&N)!=EOF){
        if(N==0){ puts("0"); continue; }
        int zero_cnt=0;
        for(;N;N>>=1)
            if((N&1)==0)
                zero_cnt++;
        printf("%ld\n",(long)1<<zero_cnt);
    }
}