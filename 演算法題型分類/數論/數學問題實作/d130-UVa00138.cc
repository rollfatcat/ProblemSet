// (數論題)題目說明：找到10组Ｎ和Ｋ，使得sum(1,K-1)==sum(K+1,N)
/* (1) 枚舉Ｎ二分法找Ｋ是否存在
 * (2) 公式推導：sum(1,K-1)＝sum(K+1,N)
 *            => K(K-1)/2＝(N-K)(N+K+1)/2
 *            => N^2+N-2*K^2＝0
 *     (X) => N＝(sqrt(8*K^2+1)-1)/2
 *         => Ｎ,Ｋ都是大於0的整數，枚舉Ｋ找到整數的Ｎ
 *     (O) => 數論，佩爾方程式的遞迴求解(題目有給兩組初始的根)
 *         => N^2+N-2*K^2＝0 ......左右兩邊同乘以４做配方
 *         => (2*N-1)^2-8*K^2＝1 ...... 這個不等式稱為『佩爾方程式』，
 *         => 佩爾方程式的標準做法：找到基礎解後可遞迴求解根
 *         => 題解：https://blog.csdn.net/u012841845/article/details/39699409
 */
#include<bits/stdc++.h>
using namespace std;

int main(){

  // 枚舉 y0 找基礎解
  // n=8 <=(2*N-1)^2-8*K^2＝1 ... Ｋ平方的係數項決定
  /* 基本解 x0, y0 可以由 sqrt(n) 的漸進連分數 h0/k0, h1/k1...h(l-1)/k(l-1),
   * l是連分數的最小正周期，若l是偶數，則 h(l-1) 和 k(l-1) 就是佩爾方程的一组特解，
   * 若l是奇數，則 h(2l-1) 和 k(2l-1) 是方程的一组特解
   */
  int x0, y0=1, n=8;
  while(true){
    x0=(int)sqrt(y0*y0*n+1);
    if(x0*x0==n*y0*y0+1)
      break;
    y0++;
  }
  // 遞迴求後面的其餘9個解根
  int prex=x0, prey=y0;
  int nowx, nowy;
  for(int i=0;i<10;i++) {
	  nowx = x0*prex + n*y0*prey;
	  nowy = y0*prex + x0*prey;
	  printf("%10d%10d\n", nowy, (nowx-1)>>1);
	  prex = nowx,
	  prey = nowy;
  }
}
// 解答：
// N[10]={ 6, 35, 204, 1189, 6930, 40391, 235416, 1372105,  7997214, 46611179}
// K[10]={ 8, 49, 288, 1681, 9800, 57121, 332928, 1940449, 11309768, 65918161}