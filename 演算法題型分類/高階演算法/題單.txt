出處:http://www.csie.ntnu.edu.tw/~u91029/Sequence2.html#6
題單(劉汝佳的競程算法為主)： https://vjudge.net/article/61

# ZKW
(v) ZJ-d801：刪除＝兩棵線段數『維護個數』和『維護極值』＋查詢號碼轉換為實際號碼的方式
(v) UVa 12086(簡單模板題)(單點修改＋區間和查詢)
(v) UVa 11297(二維)
(v) UVa 12299(區間最小值查詢＋shift=多個單點更新)


# BIT :難度1是最簡單，難度5最難
(3) ZJ-a457：求#逆數對(兩種解) => 離散化＋BIT or CDQ分治法
(4) ZJ-a572：嚴格遞增的動態規劃作法轉為離散化＋BIT，達到O(n㏒n)
(4) ZJ-a596：同上
(3) ZJ-b317：同上
(4) ZJ-c258：作法類似嚴格偏序，清楚定義的『外離』＝右端點小於目前圓的左端點，『內離』＝右端點大於目前圓的右端點
(5) ZJ-c260：前綴和+BIT維護數據結構+離散化+排容算法
(2) ZJ-c651：利用XOR的性質達到summation的同樣效果
(4) ZJ-b533：枚舉兩個點對，Ｘ軸直接排序，用BIT維護Ｙ軸。
(1) ZJ-d788
(1) ZJ-d794
(3) ZJ-d796
(3) ZJ-d799
(3) ZJ-d847：第一個維度做排序，第二個維度利用BIT找到『比這個值還小』的個數總和
(2) TIOJ-1080：逆數對BIT解法(也可以用分治法)
(5) TIOJ-1228：樹壓平(DFS遍歷順序)後紀錄每個點(當起點時)區間內的邊號碼，BIT負責處理區間內邊的總和
(1) TIOJ-1869：單點更新＋區間查詢(裸題)
(4) TIOJ-1907：BIT實作LIS，第一個維度CountSort＋第二個維度BIT，BIT[][]紀錄最大值
(4) TIOJ-1226：由值小更新到值大的，類似混搭TIOJ-1483的作法和TIOJ-1907的LIS概念
(4) TIOJ-1483：由值小更新到值大的，只是同一個值時要等到查詢完成後才全部更新
(4) ZJ-a484：由值小更新到值大的，只是同一個值時要等到查詢完成後才全部更新

(V) UVa 01428：找到比某個數字小和大的個數總和，區間查詢
(v) UVa 01513：Stack模擬轉換為BIT的查詢
(V) UVa 11525：如何確定未選的數中第k小的數
(v) UVa 12086：單點修改＋區間『和』查詢
    UVa 11423
    UVa 11610
    UVa 11601(二維)

# SparseTable
(v) UVa 11235
    UVa 11263(二維)

# SegmentTree
(3) ZJ-c652   (開根號＋線段樹)，利用開根號會快速收斂到1的概念。
(5) ZJ-a164   (連續最大區間和:DP概念+線段樹)
(v) UVa 01400 (連續最大區間和:DP概念+線段樹)


#  lazy propogate
(5) UVa 01232(因為區域內的高度參差不齊，所以只紀錄最高和最低
              最高決定是否可以覆蓋整個地區而停止，最低決定是否剪枝停止)
(v) UVa 11402(懶惰標記的重疊處理)
(v) UVa 11992(將二維分拆成數個一維，且需要支援新功能：『區間設定』)：區間更新＋區間加總/極值查詢

# 差分
    UVa 11525
    UVa 11990