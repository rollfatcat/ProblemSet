/* 給定目標數字Ｋ，± 1 ± 2 ± 3 …… ± Ｎ = K，滿足上述條件最小的 Ｎ (Ｎ ≧ 1) ？
 * 其中「±」代表可以是「加法（正）」或「減法（負）」，從其中擇一。
 * 題目盲點：乍看之下是對每個數字調整正負號的01背包分堆問題，但Ｋ極大一定是不可能。
 * 解題關鍵：數學問題
 * Ｋ＝-Ｋ：Ｋ和-Ｋ的答案只要將每個數字選取的正負號顛倒即可。
 * 從 Ｎ*(Ｎ+1)/2 ≧ Ｋ開始枚舉，差值 Ｎ*(Ｎ+1)/2-Ｋ 只要是偶數代表存在一解( 奇數一定不存在解 )？
 *    + 1 + 2 + 3 …… + X + …… + Ｎ 時將Ｘ的符號改為負的時候和原本的總和差值為"偶數"
 *    差值必定可以透調整任意個數字組成( 將差值的一半轉為二進位後可以知道要調整的是哪幾個 )
 */
#include <bits/stdc++.h>
using namespace std;
 
const int MaxK=1e9;
int main(){
	int caseT, K;
	scanf("%d\n",&caseT);
	while(caseT-->0){
		scanf("%d\n",&K);
		if(K<0) 
			K=-K;
		int N=(K==0)? 1:sqrt(K<<1);
		for(N+= (N+1)*N<(K<<1); ((N+1)*N/2-K)&1 ; N+=1);
 
		printf("%d\n",N);
	}
}