/* 給定目標數字Ｋ，± 1 ± 2 ± 3 …… ± Ｎ = K，滿足上述條件最小的 Ｎ (Ｎ ≧ 1) ？
 * 其中「±」代表可以是「加法（正）」或「減法（負）」，從其中擇一。
 * 題目盲點：乍看之下是對每個數字調整正負號的01背包分堆問題，但Ｋ極大一定是不可能。
 * 解題關鍵：數學問題
 * Ｋ＝-Ｋ：Ｋ和-Ｋ的答案只要將每個數字選取的正負號顛倒即可。
 * 從 Ｎ*(Ｎ+1)/2 ≧ Ｋ開始枚舉，差值 Ｎ*(Ｎ+1)/2-Ｋ 只要是偶數代表存在一解( 奇數一定不存在解 )？
 *    + 1 + 2 + 3 …… + X + …… + Ｎ 時將Ｘ的符號改為負的時候和原本的總和差值為"偶數"
 *    差值必定可以透調整任意個數字組成( 將差值的一半轉為二進位後可以知道要調整的是哪幾個 )
 */
#include<iostream>
#include<cmath>
using namespace std;

int main(){
  ios::sync_with_stdio(0),
  cin.tie(0), cout.tie(0);

  for(long n; cin>>n;){
    if(n<0) n=-n;
    int num=sqrt(n<<1);
    if(num*(num+1)/2<n) num++;
    for(long x=num*(num+1)/2; (x&1)!=(n&1); num++,x=num*(num+1)/2);
    cout<<num<<endl;
  }
}