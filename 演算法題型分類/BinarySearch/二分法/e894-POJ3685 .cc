/* 給定邊長Ｎ的二維矩陣 和 每個數字如何產生，求該矩陣中第Ｍ小的數字？
 * 每個位置的數字Ａ[ｉ][ｊ]＝(Ｎ-10000+ｉ)×ｉ+ｊ×(ｊ+1)
 * 固定ｉ時，(Ｎ-10000+ｉ)×ｉ可視為常數，數字隨著ｊ增加而遞增，但遞增的性質只存在每個Row。
 * 題解：二分法逼近答案，但注意收斂的問題：
 *  從選擇的範圍內不斷縮減直到『剩下一個數字』＝左右邊界交接於同一個數字
 *  以這題為例判斷式同(1)，但調整方式為：(1)左邊界＝猜測值+1 或是 (2)右邊界＝猜測值
 *  注意到：右邊界比起(1) 少了-1，因為該數字是 #矩陣中小於猜測值的數字個數 ≥ Ｍ中最小值，
 *  正確答案是剩下的唯一數字-1，是因為答案存在該矩陣中(廢話...) 故 #矩陣中小於猜測值的數字個數 ≤ Ｍ-1。
 *  我們可以注意到收斂的前一刻：左右邊界值必定差1，而猜測值是兩值取平均後的捨位。
 *  正數時猜測值＝左邊界，根據判斷式討論：不符合則左邊界更新和右邊界相同，符合判斷式則右邊界更新和左邊界相同，必定收斂。
 *  負數時猜測值＝右邊界，根據判斷式討論：不符合則左邊界更新和右邊界相同，符合判斷式則右邊界和上一次一樣＝無法收斂。
 */
#include<bits/stdc++.h>
using namespace std;

const int MaxN=1e4; //
const int INF=1<<30;
int N, M, B;
int base[MaxN];
inline int RowCount(int v){
	if(v<=0)  return 0;
	if(v>B )  return N;
	int tag=sqrt(v);
	return tag+(v>tag*(tag+1));
}
int main(){
	
	while(scanf("%d %d\n",&N,&M)!=EOF){
		B=N*(N-1);
		for(int i=0;i<N;i++)
			base[i]=(N-10000+i)*i;
		int nL=-INF, nR=INF;	
		while(nL<nR){
			int nM=(nL+nR)/2, cnt=0;
			// 猜測值是負數時固定取左邊界
			if(nM<0) nM--;
			for(int i=0;i<N;i++)
				cnt+=RowCount(nM-base[i]);
			(cnt>=M)? nR=nM: nL=nM+1;
		}
		printf("%d\n",nL-1);
	}
}
