//// 文章出處：https://debug.fanzheng.org/post/merger-tree-and-parti-tree.html
歸併樹 vs 劃分樹(只可解決『靜態』/『離線狀態』區間第K大的數)
  博客上許多文章皆是混搭使用兩者，不是空間浪費就是多耗去多餘的時間

歸併樹：
  建樹時間成本是 N㏒N，MergeSort的Bottom-Up合併
  單次查詢成本是 (㏒N)^3
  實作原理：MergeSort＋SegmentTree( N㏒N + M(㏒N)^3 )
    用線段樹紀錄下歸併的過程可以得到 ㏒N 個長度為n的序列(SparseTable空間量)
    將這 ㏒N 個序列縱向展開按照『線段樹』的形式分解區間，每個序列即是線段樹的同一層Node
    (0th 序列是遞增/遞減的序列， ㏒Nth 序列是原始數據)

  建樹過程：
    h=0 [1, 2, 3, 4, 5, 6, 7, 8]  <-遞增數列
    h=1 [1, 3, 5, 7][2, 4, 6, 8]
    h=2 [3, 5][1, 7][2, 4][6, 8]
    h=3 [5][3][1][7][4][2][8][6]  <-原始數據

  查詢成本解說(3個㏒N的由來)：
  1. 針對線段樹內單一個區間(MergeSort時已將該區間排序完成)找到 目標元素val 是第K大數是二分搜尋。
  2. 將原問題的區間[qL,qR]拆分成線段樹中 ㏒N 個區間，分次拜訪並累計rank值
  3. 二分法枚舉排序好的數列中元素val在指定區間內的rank值，設法找出符合條件的最小值

  經典練習題：
    ZJ-a331(POJ-2104) - 解法：http://mypaper.pchome.com.tw/zerojudge/post/1323170731

劃分樹：
  建樹時間成本是 N㏒N，需事先搭配一個經過排序的數列
  單次查詢成本是 ㏒N
  實作原理：
    建樹依賴經過排序完成的數列，且需要比起歸併樹多出一倍的空間完成查詢
    原始數據為 org，經排序後的數據則為srt，以求建樹過程中知道區間[nL,nR]的中間值。
    建構下一層的區間時中間值是 srt[(nL+nR)/2]，小於等於中間值的分配到左子樹，右子樹則是大於的部分。
    處理的同時也記錄(包含)現在這個數字的左邊有幾個數字屬於左子樹。
    上述的目的是要做單次詢問時的加速：
    在詢問區間[qL,qR]時只需要 toL[qR]-toL[qL-1] 就可以知道這整個區間有多少個數字屬於左子樹，
    如果數量大於等於要詢問的 qK(要查的是第K大数的值)，
    說明必定要往左區間繼續找qK，否則右區間找 qK-(toL[qR]-toL[qL-1])。
    需要注意的是，詢問的區間[qL,qR]也要相應修改。
    例如：假設線段樹區間是nL和nR。
    如果要繼續詢問的是左區間，那麼[qL,qR] => [ nL+toL[depth][qL-1],nL+toL[depth][qR]-1 ]，
    因為有 toL[depth][qL-1] 個數字跑到了左區間的最左邊，而這 toL[depth][qL-1] 個數字不在我们指定的[qL,qR]區間内。
    右區間同理要改成 [ nM+1+qL-nL-toL[depth][qL-1], nM+1+qR-nL-toL[depth][qR] ]。
    而且這樣的寫法能夠保證指定的[qL,qR]一定在線段樹的區間[nL,nR]之内。

  細節注意(當原始數據包含『重複』的數字時)：
    中間值為 srt[(nL+nR)/2] 的元素可能有多個，必然要出現其中一部分在左區間，另一部分在右區間的情況，
    不能直接依照『小於等於 srt[(nL+nR)/2] 的放左邊其他在右』来處理。
    解決方法是先找一下有多少個元素是小於 srt[(nL+nR)/2] 的於是就可以知道剩下多少個位置是留给恰好等於中間值。

  建樹過程：
    h=0 num[] = [5, 3, 1, 7, 4, 2, 8, 6]  <-原始數據
        toL[] = [0, 1, 2, 2, 3, 4, 4, 4]
    h=1 num[] = [3, 1, 4, 2][5, 7, 8, 6]
        toL[] = [0, 1, 1, 2][1, 1, 1, 2]
    h=2 num[] = [1, 2][3, 4][5, 6][7, 8]
        toL[] = [1, 1][1, 1][1, 1][1, 1]
    h=3 num[] = [1][2][3][4][5][6][7][8]  <-遞增數列

  經典練習題：
    ZJ-a331(POJ-2104) - 解法：https://debug.fanzheng.org/post/merger-tree-and-parti-tree.html

////
主席樹(函數式線段樹/可持久化結構：可解決『動態』區間第K大的數)

  教學文：https://www.jianshu.com/p/e1d46a714fa8

  可持久化的數據精神，有一種為函數式線段樹，最簡單理解的就是採用修改不改值，而是增加新的節點，
  而每一次修改最多增加 Ｏ(ＮlogＮ) (延著線段樹走訪路徑增加節點)也就是說，
  每一次修改會根據前一次的 root 增加一個新的 root'，這是一個相當重要的一環，
  每一次修改會產生新的一棵線段樹，而這個新線段樹大部分節點會使用前一個線段樹的節點，
  因此只要針對走訪不影響的情況下，我們仍然會經過舊有的節點。為了找到區間 K 大，
  使用函數式線段樹有點類似於掃描線算法，對於某個時間點依序將數字放進去，
  然後對於區間查詢 K 大的時候，相當於對某個時間點之間作減法運算。

  比較：
  時間(快到慢)：歸併樹 > 函數式線段樹 > 塊狀鏈表
  空間(多到少)：函數式線段樹 > 歸併樹 > 塊狀鏈表

  經典例題：
  (1)求區間內第 K 小的數字
    ZJ-a331(POJ-2104)
    該題標準解法有兩種：如上的主席樹和歸併&劃分樹
    ZJ-a063


https://blog.csdn.net/woshinannan741/article/details/53012682
https://blog.csdn.net/Stupid_Turtle/article/details/80445998
https://blog.csdn.net/creatorx/article/details/75446472
https://blog.csdn.net/qq_34374664/article/details/77894271