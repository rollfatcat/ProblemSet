/* 動態規劃經典例題：Best Time to Buy and Sell Stock
 * (1) 過程中只能買賣一次：最低點買入且最高點賣出且買入最低點的時間必須發生在賣出最高點的時間
 *     (X) 搜尋整個數列的最大值/最小值後輸出差
 *     (O) 掃描整個數列過程中紀錄目前買入的最低點。
 *         若目前價格高於最低點，則當天可能是賣出的最高點，計算價差後看能否更新最大利潤
 *         若目前價格低於最低點，則當天可能是買入的最低點，更新買入的最低點
 * (2) 過程中可以買賣無限次：每天只能選擇買入或者賣出
 *     每天只能選擇買入或者賣出時，必須選取所有的遞增區域並計算起點和結尾的差價。
 *     考慮case：1 3 5，答案是第一天買入並在第三天賣出，但也可以視為第一天買入第二天賣出並且第二天買入第三天賣出
 *     第二天同時發生買入和賣出的行為會相互抵銷，等於沒有做任何的事情。
 *     將同樣的概念套用在問題，只要加總所有目前價差是正的即可。
 *     (O) 將每個價格作為點並且把所有的點連起來，只取連線的斜率是正的線段的做加總。
 * -> 本題屬於這類型：測資範圍 5 ≦ n ≦ 1e4，0 ≦ i ≦ 1e4
 * (3) 過程中可以買賣2次：每天能同時選擇買入或者賣出，但只同一時間點允許持有一組股票
 *     因為同一時間點只允許持有一組股票，問題可以等價為 枚舉切點將整個數列分成兩段之後各自套上(1)的作法
 * (4) 過程中可以買賣Ｋ次：：ZJ-c457
 */
#include<bits/stdc++.h>
using namespace std;

int main(){
  int N, pre, now;
  while(scanf("%d",&N) and N){
    int sum_diff=0;
    scanf("%d",&pre);
    for(int i=1;i<N;i++){
      scanf("%d",&now);
      if(now>pre) sum_diff+=now-pre;
      pre=now;
    }
    printf("%d\n",sum_diff);
  }
}
/*
4
1 3 2 4

*/